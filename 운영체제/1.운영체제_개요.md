## 운영체제란?

![스크린샷 2024-04-06 오후 5.20.43.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/02620ba0-61c4-4554-a346-fb0e7083bc83/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.20.43.png)

- 컴퓨터 하드웨어 바로 위에 설치된 소프트웨어
- **사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층**
- 자원을 효율적으로 관리
- 하드웨어를 직접 다루는 복잡한 부분 담당
- CPU, 메모리, 하드디스크 등을 관리
- 좁은 의미의 운영체제
  - **커널**
  - 운영체제의 핵심으로, 메모리에 상주하는 부분
  - 컴퓨터가 켜지면 메모리에 올라와서, 꺼질 때까지 존재함
- 넓은 의미의 운영체제
  - 커널 뿐만 아니라 각종 주변 시스템 유틸리티를 포함한 개념
  - 파일 복사 기능 등..

## 운영 체제의 목적

![스크린샷 2024-04-06 오후 5.27.37.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/f8241813-ed19-4827-b567-e2b59fe7bf88/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.27.37.png)

- 컴퓨터 시스템을 편리하게 사용할 수 있게 함
  - 사용자가 컴퓨터의 하드웨어에 대해 잘 몰라도 컴퓨터를 편하게 사용할 수 있게 해주는 인터페이스 제공
- 동시 사용자/ 프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상(illusion)을 제공
  - 한 대의 컴퓨터에서 여러 프로그램을 사용하더라도
  - 한 대의 서버에 여러 사용자가 접속할 때, 나 혼자만 이를 사용하는 것처럼 느끼게 해줌
- 컴퓨터 시스템의 자원을 효율적으로 관리
  - CPU, 메모리, I/O 장치 등의 효율적 관리
    - **실행 중인 프로그램들에게 짧은 시간씩 CPU를 번갈아가며 할당**
    - **실행 중인 프로그램들에 메모리 공간을 적절히 분배**
      - 프로그램에게 메모리를 1/n해서 공평하게 할당해주는 게 합리적이지 않음
      - 메모리를 쓰고난 뒤 I/O를 하러 가면 새로운 프로그램이 메모리에 할당되고~ 이게 반복
- 사용자 간의 형평성 있는 자원 분배(자원 관리자)
- 주어진 자원으로 최대한의 성능을 내도록
  - 사용자 및 운영체제 자신의 보호
  - 프로세스, 파일, 메시지 등을 관리
- 교수님 생각
  - CPU는 기계어를 빠르게 실행하는 능력을 가졌지만 스스로 판단하지는 못함
  - 메모리든 CPU든 하드웨어는 판단하는 능력을 가지고 있지 않기에 운영체제가 컴퓨터의 두뇌 아닐까?

## 운영 체제의 분류

### 기준

- 동시 작업 가능 여부
- 사용자의 수
- 처리 방식

### 동시 작업 가능 여부

- 단일 작업
  - 한 번에 하나의 작업만 처리
  - 예) MS- DOS 프름프트상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음
  - 아주 초창기의 운영체제는 단일 작업만 가능했음
- **다중 작업**
  - 동시에 두 개 이상의 작업 처리
  - 예) UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음
  - **_현대의 운영체제는 다중 작업이 가능함_**
    - 다중 작업이 가능하기에 메모리 할당, CPU 할당 문제가 생기는 거임

### 사용자의 수

- 단일 사용자
  예) MS-DOS, MS Windows
- **다중 사용자**
  예) UNIX, NT Server

### 처리 방식

- 일괄 처리(batch processing)
  ![스크린샷 2024-04-06 오후 9.36.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/23256253-c86d-4a51-bf5c-2798c6cd2a87/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.36.21.png)
  - 작업 요청의 일정량 모아서 한꺼번에 처리
  - 작업이 완전 종료될 때까지 기다려야 함
    예) 초기 Punch Card 처리 시스템
- **시분할 (time sharing)**
  ![스크린샷 2024-04-06 오후 9.37.28.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/02ce74f0-0c19-4893-80f9-8befbb7a9433/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.37.28.png)
  - 여러 작업을 수행할 때, 컴퓨터 처리 능력(메모리, CPU와 같은 자원)을 일정 시간 단위로 분할하여 사용
  - 사용자의 요청에 대한 응답이 바로 옴
  - 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐 예)UNIX
  - interactive한 방식
- 실시간(Realtime OS)
  - 정해진 시간 안에 어떠한 일이 반드시 종료되어야하는 실시간 시스템을 위한 OS
  - 예) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어
  - 개념 확장
    - Hard Realtime System (경성 실시간 시스템)
      - 데드라인을 어기면 큰 일
    - Soft Realtime System (연성 실시간 시스템)
      - 데드라인을 어기면 심각한 문제까진 안 생기는
      - 동영상 스트리밍은 초당 24프레임을 찍어내야하는데 다 못 찍어내서 끊기는 경우
      - 운영체제에서 연성 실시간 시스템을 돌릴 수는 있음 하지만 보장은 못해줌
  - 참고로 우리가 사용하는 운영체제는 데드라인이 없음

⇒ 현재 우리가 사용하는 운영체제는 **다중 작업, 다중 사용자, 시분할 운영체제**

## 용어 정리

- Multi-tasking
  - 프로그램 여러 개를 동시에 돌리는 것
- Mutli-programming
  - 메모리의 관점
  - 메모리에 여러 프로그램이 동시에 올라가있는 것
- Time-sharing
  - CPU의 관점
  - 하나의 CPU를 시간을 나누어 사용함
- Multi-process
- 구분
  - 위의 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 걸 의미함
  - Multi-programming은 여러 프로그램이 메모리에 올라가 있음을 강조
  - Time-Sharing은 CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조
- Multi-processor
  - 하나의 컴퓨터에 CPU가 여러 개 붙어 있음을 의미
  - 동시에 여러 프로그램들이 서로 다른 CPU에서 병렬적으로 일을 할 수 있음

## 운영체제의 예

- 유닉스 (UNIX)
  - 코드 대부분을 C언어로 작성
    - 원래는 어셈블리어로 프로그래밍을 해야했음
    - C언어는 하드웨어를 효율적으로 관리하기 위한 고급언어
    - 사람이 이해하기 쉬움
  - 높은 이식성
    - 고급 언어이기에 가져다가 쓰기도 편함
    - 여러 아키텍쳐에서 호환됨
  - 최소한의 커널 구조
  - 복잡한 시스템에 맞게 확장 용이
  - 소스 코드 공개
    - 초창기에는 소스 코드를 공개했었음
    - 이후에는 유료
  - 프로그램 개발에 용이
  - 다양한 버전
    - 리눅스, 솔라리스, 시스템 브이, Sun OS
- DOS(Disk Operating System)
  - MS사에서 1981년 IBM-PC를 위해 개발
  - **단일 사용자, 단일 작업용** 운영체제, 메모리 관리 능력의 한계(주 기억 장치 : 640KB)
- MS Windows
  - MS 사의 **다중 작업용** GUI 기반 운영체제
  - Plug and Play 네트워크 환경 강화
  - DOS용 응용 프로그램과 호환성 제공
  - 풍부한 지원 소프트웨어

## 운영체제의 구조

![스크린샷 2024-04-06 오후 10.08.19.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/10f39b0e-0dfa-40c7-bdb0-449b02ef31bc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.08.19.png)

## 컴퓨터 시스템의 구조

![스크린샷 2024-04-06 오후 5.39.54.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/e1cc1bc0-880f-49bf-838a-7308a3a21df3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.39.54.png)

- 컴퓨터 내부
  - CPU가 메모리에서 매 번 기계어를 읽어서 작업을 함
- 컴퓨터 외부 (입출력 I/O 디바이스)
  - 키보드, 마우스 - input 디바이스
  - 프린터, 모니터 - output 디바이스
  - 하드디스크 - input, output 모두 가능한 디바이스
    - 여기서 뭔가 읽어다가 컴퓨터가 작업을 하면 input
    - 처리 결과를 저장하면 output

## 운영체제의 기능

![스크린샷 2024-04-06 오후 5.44.28.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/1fefa60a-52fb-4a85-8303-cf04fd10b910/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.44.28.png)

- 컴퓨터가 부팅됨 = 운영체제가 메모리에 올라가 실행됨
- 컴퓨터가 꺼질 때까지 항상 실행되는 부분이 운영체제
- 운영체제의 핵심 “커널”
  - 메모리에 상주함, 언제나 메모리에 올라와있음
  - 운영체제를 제외한 나머지 메모리 부분은 컴퓨터로 작업하는 여러 프로그램들이 차지함
- 메모리
  - CPU의 작업 공간
  - CPU는 매 clock마다 메모리의 기계어를 읽어서 연산을 함
  - 만약 CPU가 운영체제에 있는 기계어를 읽고 있다 = 운영체제가 CPU를 사용하고 있다
  - CPU가 메모리의 프로그램 C 위치에 있는 기계어를 읽고 있다 = 프로그램 C가 CPU를 사용하고 있다
- CPU
  - CPU의 작업 공간은 “메모리”
  - 따라서 하드디스크나 외부 I/O 장치에 직접 접근 못함
    - I/O 디바이스들은 각자의 CPU가 달려있음 ⇒ I/O 컨트롤러
      - CPU가 I/O 디바이스에게 일을 시키면
      - 각 I/O 디바이스의 컨트롤러가 일을 한 다음
      - 각 I/O 디바이스의 메모리에 저장을 해둠
- CPU 스케쥴링
  - 1. 어떤 프로그램에게 CPU 사용권을 줄 것이냐
  - 2. 그 프로그램에게 얼마나 오래 사용권을 줄 것이냐
  - CPU는 하드웨어이기에 매 번 메모리를 읽어서 작업을 하는 것 밖에 못함
  - CPU가 각 프로그램에게 권한을 주는 게 X
  - 운영체제가 00 프로그램에게 권한을 주라는 명령어를 주면, CPU가 그걸 읽어서 그 프로그램에게 권한을 넘기는 거임
  - 모든 하드웨어의 관리는 운영체제가 함
  - A라는 프로그램을 CPU에서 실행하다가, 디스크에서 뭔가를 읽어와야할 때
  - 디스크는 CPU보다 100만배 느리기에 CPU는 계속해서 기다려야함
    - 이러한 경우에 CPU는 다른 프로그램으로 넘어가게 됨
  - CPU가 I/O 디바이스의 컨트롤러에게 일을 시킨 다음, I/O 디바이스는 매우 느리기에 그 다음에 할 일을 찾음
- 디스크 스케쥴링
  - 여러 프로그램이 디스크에게 동시에 요청을 보내는 경우가 있을 수 있음
  - 먼저 도착한 순서대로 이를 처리하면 굉장히 비효율적이기에
  - 나중에 들어온 요청일지라도 그걸 먼저 처리하는 게 효율적이라면 미리 처리함
  - 예) 엘리베이터
- 인터럽트, 캐싱
  - CPU와 I/O 장치 간 속도차이 극복 방법
  - 캐싱
    - 같은 데이터를 또 읽어달라고 하는 경우에 미리 가져와 저장해둔 데이터로 응답해줌
  - 인터럽트
    - 가로채기
    - CPU는 I/O 디바이스의 컨트롤러에게 시킨 일의 결과값을 인터럽트라는 방법으로 전달받음
    - **인터럽트가 들어오게 되면, CPU 제어권이 자동으로 운영체제에게 넘어가게 됨**
    - 운영체제는 다음에 해야할 일을 파악함
    - 즉, CPU가 느린 장치에게 일을 시키고 난 뒤 다른 할 일을 하다가 인터럽트가 들어오면 CPU의 제어권이 자동으로 운영체제로 넘어가게 됨

## 인터럽트

- **타이머 인터럽트**
  ![스크린샷 2024-04-06 오후 8.28.34.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/75dbec37-30b7-4842-9972-d3eb8ce958d9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.28.34.png)
  - CPU를 프로세스들에 번갈아 할당하기 위해 사용
- **I/O 디바이스 컨트롤러에 의한 인터럽트**
  ![스크린샷 2024-04-06 오후 8.28.47.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/b25134c0-fc2c-4b9d-a70d-f964f652f4ed/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.28.47.png)
  - 요청한 입출력 작업이 끝났음을 CPU에 알려주기 위해 사용

## 프로세스의 상태

![스크린샷 2024-04-06 오후 6.30.01.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/f49376fc-d845-48c6-8b09-65f9fd6ff20e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.30.01.png)

- 프로그램들은 큐로 줄 세워짐
- interactive application
  - IO와 CPU를 번갈아 사용함
  - 사람과 인터렉션함
  - 예) 사용자의 키보드 입력 → 키보드의 인터럽트 → CPU는 운영체제에 넘어감 → 키보드 입력을 기다리던 프로그램이 CPU 큐에 들어감 → 그 프로그램에 대한 CPU의 연산 결과가 모니터와 같은 출력 디바이스에 출력됨
- Scientific Application
  - IO와 CPU를 왔다갔다하는 게 아니라
  - CPU 다 사용한 다음 IO로 넘어가는 그러한 경우
- 이 부분 이해 안가면 영상 끝부분 다시 봐도 좋을듯

## CPU 스케쥴링

- 여러 프로그램이 CPU를 사용하고자 할 때, 어떤 프로그램에게 먼저 CPU 사용권을 줄 것인지
  - 운영체제가 결정함

### FCFS(First-Come First Served)방법

![스크린샷 2024-04-06 오후 6.44.24.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/0470ba18-bb42-4214-b67b-db8552d9fe45/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.44.24.png)

- 3개의 프로그램이 CPU를 쓰겠다고 P1, P2, P3 순서대로 도착함
- FCFS(먼저 온 사람에게 먼저 서비스)인 예시에서는
  - P1이 가장 먼저 요청을 했기에, P1부터 처리함
  - P1은 24초를 다 쓰고, IO를 하러 감
  - P2, P3도 마찬가지
- 공평한 거 같지만, 효율적이진 않음
- P1이 오래 CPU를 점유하는 바람에 waiting time이 길어짐

![스크린샷 2024-04-06 오후 6.56.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/ffcfecd9-1652-482d-b951-396e4c0fb175/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.56.17.png)

- 만약 이 상황처럼 P2가 먼저 도착했다면, CPU를 짧게 점유하기 때문에 평균 대기 시간이 적어짐
- 17초에서 3초로 확연히 줄어듦

### SJF(Shortest-Job-First) 방법

![스크린샷 2024-04-06 오후 6.59.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/fe5508ab-ea49-484f-8478-4bc41abdb749/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.59.11.png)

- CPU 사용 시간이 **가장 짧은 프로세스를 가장 먼저 스케쥴링**
- **최소 평균 대기 시간을 보장해줌**
- **효율성에는 좋지만, 형평성에는 문제가 있음**
  - 무한정 기다리는 문제가 생길 수 있음
  - **긴 프로그램은 영원히 CPU를 사용하지 못하는 경우가 존재**함

=> FCFS와 SJF 이 두 가지 방법은 일단 프로세스가 CPU를 점유하면, 뺏지는 않는다고 가정했음

### RR (Round Robin) 방법

![스크린샷 2024-04-06 오후 7.07.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/4d9bf4f3-91db-4df2-9b50-3daa6427a7d5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.07.15.png)

- 하나의 프로세스가 CPU를 사용할 수 있는 시간(할당 시간)이 동일하게 정해져있음
  - (일반적으로 10-100 milliseconds)
- 그 시간이 지나버리면, 프로세스는 CPU를 빼앗기고, 다시 큐의 맨 뒷 자리에 줄을 서야함
- n개의 프로세스가 CPU 큐에 있고 할당 시간이 q time unit인 경우 각 프로세스는 최대 q time unit 단위로 CPU 시간의 1/n을 얻는다.
  ⇒ 어떤 프로세스도 (n-1) \* q time unit 이상 기다리지 않는다.
- CPU를 빼앗는 건 운영체제 혼자 할 수 있는 건 아니기에, 하드웨어적인 지원을 받아 인터럽트를 발생시켜 빼앗음
- 각 프로세스가 CPU를 사용하려는 시간에 비례해서 대기 시간이 달라짐

## 메모리 관리

![스크린샷 2024-04-06 오후 7.12.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/f040b5c7-1f63-42b4-ac47-9c546d90e0fe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.12.42.png)

- 디스크에 실행 파일 형태로 프로그램이 존재하고,
- 메모리는 휘발성이기에 비어있다가 전원을 켜면 운영체제가 메모리에 올라오고,
- 디스크의 실행 파일을 실행시키면, 이것들이 메모리에 올라가서 프로세스가 됨
- 정확하게는 메모리에 바로 올라가는 게 아니라 한 단계가 하나 더 있는데 그게 바로 가상 메모리임

![스크린샷 2024-04-06 오후 7.14.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/6b1d9417-d4cf-4e86-9ab8-2363568c78a2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.14.04.png)

- 각 실행파일은 본인만의 가상 메모리 공간을 형성함
- **스왑 영역**

  - 가상 메모리 중 당장 필요한 부분만 실제 메모리에 올라감
  - 가상 메모리의 크기가 크기 때문에 이걸 통째로 올리게 되면, 당장 사용하지 않을 부분까지 올라가게 되어 메모리가 낭비됨 ⇒ 나머지 부분은 스왑 영역으로 이동됨
  - 메모리가 다 차버리면, 쫓아내게 되는데 이것들은 스왑 영역으로 옮겨짐
  - 이는 메모리의 연장 공간임

- 디스크(파일 시스템), 디스크(스왑 영역) = 비휘발성
  - 파일 시스템 - 사진 파일, 실행 파일, 문서 등등
  - 스왑 영역도 비휘발성이긴 하지만, 프로세스가 존재할 때에 의미있기 때문에 컴퓨터 전원이 나가면 비휘발성인게 무의미해짐
- 메모리(dRAM) = 휘발성

### 메모리 공간이 꽉 찼을 때 어떤 걸(어떤 페이지) 쫓아낼 것인가?

![스크린샷 2024-04-06 오후 7.25.32.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/89de65cb-8de2-4a36-afc2-6cea11dd287d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.25.32.png)

- 현 상황에서 메모리가 다 찼기 때문에 메모리에서 특정 페이지를 쫓아내고 5번을 넣어야함
- 어떤 페이지를 쫓아내야할까?
  - 운영체제는 효율성의 측면에서 가까운 미래에서 사용될 가능성이 낮은 페이지를 쫓아내는 게 좋음
- LRU = 가장 오래 전에 참조한 페이지 삭제 ⇒ 여기서는 1번
  - 최근 히스토리의 영향력을 중요시함
  - 사용 횟수가 많음에도, 최근에 사용되지 않았다고 우선 순위가 낮아지는 문제가 발생
- LFU = 참조 횟수가 가장 적은 페이지 삭제 ⇒ 여기서는 4번
  - 과거에 많이 사용된 페이지는 또 사용될 가능성이 높다는 가정임
  - 인기 있는 데이터는 자주 사용된다
  - 인기라는 건 시간에 따라 달라질 수 있다는 점을 간과함

## 디스크 스케쥴링

![스크린샷 2024-04-06 오후 7.48.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/9d5081cc-69fc-4ed8-beeb-bb93f814db9c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.48.23.png)

- 디스크는 원판 회전 형태임
- 가장 바깥 트랙이 1번, 안 쪽 트랙이 100번
- 디스크 접근 시간에 가장 많은 시간을 차지하는 게 “디스크 헤드의 이동 시간”
- 따라서 헤드의 이동을 최대한 줄이는 게 중요함
- 큐에 들어온 순서대로 작업을 진행하는 게 효율적이지 않다는 의미

### 디스크 접근 시간 구성

![스크린샷 2024-04-06 오후 7.51.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/b607a678-274d-418b-b6b9-53a791657379/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.51.14.png)

- 탐색 시간(Seek time)
  - 가장 많은 시간을 차지함
  - 디스크의 헤드가 이동하는 시간
    - 헤드를 해당 트랙(실린더)으로 움직이는데 걸리는 시간
- 회전 지연(Rotational latency)
  - 헤드가 원하는 섹터에 도달하기까지 걸리는 시간
  - 디스크가 회전하면서 원하는 섹터가 헤더에 도착해야만 데이터를 읽거나 쓸 수 있음
  - 탐색 시간 다음으로 오래 걸리는 부분
- 전송 시간(Transfer time)
  - 실제 데이터의 전송 시간

⇒ 따라서 디스크 스케쥴링은 탐색 시간(seek time)을 최소화하는 게 목표임

### FCFS(First come First Served) 예시

![스크린샷 2024-04-06 오후 7.56.07.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/2b804061-25bc-4436-942c-2a6785a24bbb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.56.07.png)

- 큐에 적혀있는 번호는 트랙(실린더)의 번호
- 현재 트랙의 위치는 53번

### SSTF(Shortest Seek Time First) 예시

![스크린샷 2024-04-06 오후 7.59.08.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/fb05c919-32b8-466f-a9da-333d25584739/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.59.08.png)

- 현재 헤드의 위치를 기준으로 가장 가까운 요청부터 처리함
- 53 → 65 → 67 …
- Starvation 문제
  - 누군가는 영원히 서비스를 못 받고 기다려야함
  - 멀리 위치한 요청은 계속 기다려야함
  - 왜냐면 큐에는 새로운 요청들이 계속 들어오기 때문
- 효율성은 높지만, 형평성이 낮음

### 디스크 스케쥴링의 근간이 되는 방법 SCAN

![스크린샷 2024-04-06 오후 8.02.00.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/3d3f43c9-f127-4ffc-a6e1-bd196666124e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.02.00.png)

- 큐의 위치에는 관심이 없음
- 헤드는 계속 한 쪽으로 이동하면서, 헤드의 현 위치에 요청이 존재하면 처리함
  - 헤드가 디스크의 한 쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리함
  - 다른 한쪽 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동
- 헤드의 이동 거리가 짧아짐
- 엘리베이터 스케쥴링도 이에 해당됨
  - 1층에서 100층으로 가는 중에 2층에서 올라가려는 사람을 데리고 올라감

## 저장 장치 계층 구조와 캐싱

![스크린샷 2024-04-06 오후 8.04.47.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/e0fb9287-2960-4bd0-8c30-726daca4fe21/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-06_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.04.47.png)

- 이 그림의 맨 위에 CPU가 존재함
- 메모리와 IO 장치 간 속도 차이를 완충하기 위한 방법 = 캐싱
- 레지스터와 메인 메모리의 속도 차이를 완충하기 위해 캐시 메모리가 존재
- 계층도는 위로 올라갈수록 빠르고, 아래로 내려갈수록 느림
- 또한 위로 올라갈수록 비싸고, 아래로 내려갈수록 쌈
- 위 쪽은 휘발성, 아래 쪽은 비휘발성
- Primary - 메인 메모리가 속해있는 곳, CPU가 직접 실행 가능함. 컴퓨터 내부에 해당
- Secondary - CPU가 직접 접근하지 못하고, 접근 하려면 Primary에 올려두고 접근해야함. I/O 장치에 해당
- 위에서 처리하려면 올리고 올리고~ 아래에 저장하려면 내리고 내리고~

- 캐싱이란?
  - 동일한 데이터를 다시 요청하는 경우, 중간 경로에 저장해둔 다음 가져다 쓴다
  - 출발 위치보다 더 빠른 계층으로 복사를 해두는 것임
  - 용량이 한정되어있기에 어떤 것을 쫓아내는 과정이 필요하긴 함

## 플래시 메모리

- **반도체 장치**
  - 하드 디스크는 기계식 장치임 ⇒ 원판이 회전하며 마그네틱에 정보를 저장함
- NAND형, NOR형이 존재하며 보통 우리가 사용하는 건 다 NAND 형
- 하드 디스크가 아닌 SSD를 넣으면 더 비싸고 빨라짐
  - SSD란? 플래시 메모리가 들어간 저장 장치

### 특징

- 비휘발성
- 전력 소비가 적음
  - 아무래도 하드 디스크는 원판을 돌리려면 전력이 듦
- 물리적인 충격에 강함
- 크기가 작고 가벼움

⇒ 즉, 모바일 장치에 사용하기에 좋음

- 하지만 쓰기 횟수 제한이 존재함
  - 썼다 지웠다를 일정 수준 이상 하면 더이상 사용 불가능
- 데이터가 변질될 수 있음
  - 하드 디스크는 오래되어도 데이터를 읽는데에 문제가 없음
  - 하지만 플래시 메모리는 셀의 전하의 양으로 0,1을 구분하기에 시간이 흐르면 전하가 빠져나가는 경향이 있음
  - 따라서, 소프트웨어를 만드는 사람들이 전하의 양을 일정 시간 유지하거나, 특정 셀만 많이 사용되지 않고 골고루 플래시 메모리를 사용할 수 있게 조절해줘야함

### 사용 형태

- 모바일 장치, USB, SD 카드, 하드 디스크 대용인 SSD,

## 운영체제의 종류

- 서버용
  - 리눅스
- PC용
  - 리눅스
  - MAC OS
  - 윈도우즈
- 스마트 디바이스용
  - 안드로이드
    - 리눅스 커널
  - IOS

⇒ 리눅스는 오픈 소스 소프트웨어이며, 모든 종류의 컴퓨터에서 사용됨

- 오픈 소스란?
  - 내용물이 아니라 소스 코드가 공개되었다는 의미
  - 많은 곳에서 사용될 수 있는 이유도 소스코드가 공개되어있어서 이를 활용하는 거임
  - 윈도우즈의 경우 오픈 소스가 아닌데, 이는 소스코드를 컴파일한 결과인 실행 파일을 판매하는 거라고 보면 됨
    - 이는 바이너리 코드이기 때문에 원래 어떤 소스 코드였는지 파악할 수 없음
