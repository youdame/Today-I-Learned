# 컴퓨터 시스템 구조

![스크린샷 2024-04-11 오후 4.16.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/b9ba0a0f-32b5-4964-b727-7fc203ad1cd5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.16.17.png)

![스크린샷 2024-04-11 오후 4.41.48.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/4bbd02fe-6858-4c0e-98d0-9b01efe853d7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-11_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.41.48.png)

## 컴퓨터 내부

- CPU(Main CPU) = 하드웨어

  - CPU는 Program counter가 다음 번에 실행할 명령어의 주소를 알려주면 해당 명령어를 실행
  - Register
    - CPU 내부에서 정보를 저장할 수 있는 메모리보다 빠른 공간
  - mode bit
    - CPU에서 실행되고 있는 게 운영체제인지, 사용자 프로그램인지 구분해주는 역할을 함
  - Interrupt line
    - 키보드의 입력, I/O 디바이스의 일처리 완료 등을 CPU에 전달해주는 역할을 함
    - CPU는 I/O 디바이스에 직접 접근하지 않고 항상 메모리에 있는 Instruction만 실행함
      - A 프로그램에서 사용자의 입력이 필요 → 프로그램이 자진해서 OS에게 CPU를 넘김 → 운영체제가 I/O 디바이스의 컨트롤러에게 요청 → CPU는 B 프로그램의 명령어를 실행함
      - I/O 디바이스의 컨트롤러가 사용자의 입력을 잘 처리했다면, 로컬 버퍼에 저장해두고 interrupt를 검 → CPU가 Interrupt line을 읽음으로써 Interrupt를 인지하면 제어권이 운영체제에게 옮겨감 → 키보드의 로컬 버퍼에 저장된 값을 프로그램 A의 메모리 영역에 복사만 해줌 → B 프로그램에게 할당된 시간이 남아있다면 B가 CPU 제어권을 돌려받음 → 타이머가 끝나면 돌아돌아 A가 CPU 제어권을 받음

- Memory(Main memory)
  - CPU의 작업 공간
  - 운영체제
    - 모든 I/O는 운영체제를 거쳐야만함
      - 사용자 프로그램이 직접 I/O 요청을 하지 못함

⇒ 따라서 컴퓨터는 CPU와 메모리임

⇒ CPU는 매 Clock마다 메모리에서 기계어를 읽어서 실행시킴

### **타이머**

- 특정 프로그램이 CPU를 독점하는 걸 막기 위함
- 어떤 프로그램이 무한루프를 돌 수도 있음
- 각 프로그램에 할당된 시간이 끝나면, interrupt line가 시간이 끝났음을 알려줌
- CPU는 매 instruction을 실행한 후에 interrupt line을 체크함
  - interrupt 들어온 게 없으면 다음 명령어 실행
  - interrupt가 있다면, CPU의 제어권이 해당 프로그램에서 운영체제로 넘어가게 됨
    - 운영체제가 CPU를 얻게 되면, 타이머 세팅과 함께 다음 프로그램에 CPU를 넘겨줌
    - 프로그램이 종료가 되면 프로그램은 CPU를 자동 반납함

### 컴퓨터 외부

- I/O 장치

  - input - I/O 디바이스의 인풋이 컴퓨터로 들어오는 것(키보드)
  - output - 컴퓨터에서 처리된 데이터가 I/O 디바이스로 내보내지는 것(모니터, 프린터)
  - 하드디스크는 보조기억장치라고 하지만, I/O 디바이스라고도 볼 수 있음
    - 하드디스크의 데이터를 메모리에서 읽어들이기도 하고,
    - 처리 결과를 하드디스크에 저장하기도 함
    - CPU와 처리 속도가 100만배 차이가 남
  - I/O 디바이스들은 각 디바이스를 전담하는 작은 CPU와 메모리가 붙어있음
    - 이를 각각 디바이스 컨트롤러, 로컬 버퍼라고 함

- **컴퓨터 전원이 켜져**있을 때, **운영체제가 메모리에 상주**해있음
- 프로그램을 **실행시키면 해당 프로그램이 메모리에 올라가면서 프로세스가 됨**

### Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제가 피해가 가지 않도록 하기 위한 보호 장치 필요
- 2가지의 모드가 존재

1. 사용자 모드 (mode bit = 1)
   - 사용자 프로그램이 실행되고 있을 때
   - 제한된 명령어만 실행 가능 ⇒ 일반 명령
   - 무슨 일이든 다 할 수 있게하면 사용자 프로그램이 문제가 될만한 일을 할 수도 있음
     - 자기 메모리 영역만 볼 수 있게
2. 모니터 모드(=**커널 모드**, 시스템 모드, mode bit = 0)
   - 운영체제의 코드 실행되고 있을 때
   - 무슨 일이든 다 할 수 있음 ⇒ **특권 명령**
     - 사용자 프로그램의 메모리에 접근, I/O 디바이스 접근 등
     - I/O은 운영체제만 할 수 있음

- 운영체제가 사용자 프로그램에게 권한을 넘겨줄 때 mode bit = 1 세팅을 해서 줌
- interrupt나 exception이 발생하면가 CPU 제어권이 운영체제로 넘어오게 되면서 하드웨어가 Mode bit = 0으로 바꿈

### 타이머

- 특정 프로그램이 CPU를 독점하는 것을 막기 위해
- 타이머에 시간을 할당한 다음 CPU를 사용자 프로그램에게 넘겨줌
  - 할당한 시간이 지나면(타이머 값이 0이 되면) CPU의 제어권을 운영체제에게 넘기는 타이머 interrupt를 발생시킴
  - 타이머는 매 클럭마다 1씩 감소
- time sharing 구현을 위해 널리 사용됨
- 현재 시간을 계산하기 위해서도 사용됨

### I/O 디바이스의 Device Controller(하드웨어)

- I/O 장치를 관리하는 일종의 작은 CPU
- 제어 정보를 위해 control register, status register를 가짐
  - CPU가 I/O 디바이스에 일을 시킬 때
- local buffer(data register)
  - I/O의 결과물을 담는 곳
  - 또는 CPU의 연산 결과를 담았두는 곳 → 이후 출력 or 저장
- CPU
  - 컴퓨터 내부의 main memory &
  - I/O 디바이스의 local buffer 둘 다 접근 가능
- I/O 디바이스
  - 컴퓨터 내부의 main memory에 접근 불가능
  - 자기 자신의 local buffer 접근 가능

⇒ 이렇게 하니 CPU가 너무 interrupt를 많이 당함

- CPU는 빠른 장치인데 인터럽트를 많이 당하면 비효율적임
- 그래서 나온 대안이 DMA controller

- device driver(장치 구동기) = software
  - OS 코드 중 각 장치별 처리 루틴
  - 각 디바이스에 알맞게 접근하기 위해서 존재
  - CPU가 I/O 디바이스에 명령을 내리기 위해 사용하는 게 device driver임

### DMA controller(Direct Memory Access)

![스크린샷 2024-04-12 오전 10.21.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/a250c376-7c86-4e90-913d-2145dd284e09/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.21.23.png)

- I/O 디바이스의 작업이 끝나고 로컬 버퍼에 어느 정도 데이터가 차면,
- 직접 I/O 디바이스의 로컬 버퍼에 있는 내용을 메인 메모리에 복사하고
- CPU에게 인터럽트를 한 번만 걸어서 일을 다 했다고 보고함
- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴
- CPU가 여러 번 인터럽트 걸려서 발생하는 오버헤드를 줄일 수 있음

  - 작은 입력 하나하나마다 인터럽트가 걸리는 건 오버헤드가 큼

- 즉, 원칙적으로는 메인 메모리에 CPU만 접근할 수 있지만,
- 인터럽트가 너무 많이 걸리는 비효율성을 막기 위해 DMA 컨트롤러도 접근할 수 있게 함
- 하지만 메인 메모리와 DMA 컨트롤러가 동시에 메인 메모리에 접근하면 데이터 일관성에 생길 수 O

  ⇒ memory controller가 이를 제어

- ~~빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용~~
- ~~CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송~~

### 입출력(I/O)의 수행

- 모든 입출력 명령은 특권 명령
- **사용자 프로그램은 어떻게 I/O를 하는가?**
  - **시스템 콜**
    - **사용자 프로그램이 운영체제의 커널 함수를 호출하는 것**을 의미
      - 사용자 프로그램은 운영체제에게 I/O를 부탁함
      - 하지만 사용자 프로그램이 직접 OS로 점프해서 접근하지 못함
        - 왜 ? mode bit = 1인 상태임
      - 따라서 프로그램이 직접 인터럽트 라인을 설정하는 명령어를 실행시킴
      - CPU는 매 명령어 실행 후 인터럽트 라인을 확인하기에 인터럽트가 걸리고, mode bit = 0으로 변경 된 후 CPU 제어권이 운영체제에게 넘어감
- 시스템 콜의 과정
  - trap(소프트웨어 인터럽트)을 이용하여 인터럽트 벡터의 특정 위치로 이동
  - 제어권이 인터럽트 벡터가 가르키는 인터럽트 서비스 루틴으로 이동
  - 올바른 요청인지 확인 후 I/O 수행
    - 파일에 대한 접근 권한이 있는지 등
  - 완료 시 제어권을 시스템 콜 다음 명령으로 옮김

### 인터럽트

- 인터럽트가 발생하면?
  - 그 시점의 레지스터와 program counter를 저장한 후
  - CPU의 제어를 인터럽트 처리 루틴에 넘김
- 인터럽트란?(넓은 의미)

  1. Interrupt(하드웨어 인터럽트)
     - 예) 타이머, I/O 컨트롤러 인터럽트(나 다 끝났어~, 사용자 입력 들어왔어~)
     - 일반적으로 인터럽트라고 하면 하드웨어 인터럽트를 말함
  2. Trap(소프트웨어 인터럽트)
     - Exception : 사용자 프로그램이 오류를 범한 경우
       - 0으로 나누는 연산 등의 오류
       - mode bit = 1인 상태에서 운영체제의 메모리에 접근하려고 하는 등
       - 해서는 안되는 일을 하게되면 인터럽트가 자동으로 걸림
     - System call : 사용자 프로그램이 운영체제의 커널 함수를 호출하는 경우
       - I/O가 필요할 때 등

- 사용자 프로그램이 I/O를 요청하는 시점에서는 소프트웨어 인터럽트(System call)
- I/O가 완료된 시점에서는 하드웨어 인터럽트를 통해 끝났음을 알림

⇒ 즉, I/O를 하기 위해서는 두 가지의 인터럽트가 둘 다 필요함

- 현대의 운영체제는 인터럽트에 의해 구동됨
  - 운영체제는 인터럽트가 들어왔을 때에만 CPU의 제어권을 잡게되는 거지
  - 그렇지 않은 경우에는 다 사용자 프로그램이 CPU를 사용하고 있음
- 관련 용어
  - 인터럽트 벡터
    - 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    - 각 인터럽트가 들어왔을 때 어디에 있는 함수를 실행해야하는지에 대한 **주소를 가지고 있는 곳**
  - 인터럽트 처리 루틴(interrupt handler)
    - 해당 인터럽트를 처리하는 커널 함수
    - 인터럽트 백터로 함수를 찾아가면 있는 것
    - **각 인터럽트 종류마다 해야하는 일이 다름 → 이를 코드로 정리해둔 것**

### 시스템 콜

![스크린샷 2024-04-12 오전 9.31.52.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/4a92fb80-abd4-40b7-98e4-077d2cbf7d74/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.31.52.png)

- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것

### 동기식 입출력과 비동기식 입출력

![스크린샷 2024-04-12 오전 9.56.58.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/2b185ccc-303c-4c04-83d5-59aa902a340c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.56.58.png)

- 동기식 입출력 (synchronous I/O)
  - A 프로그램이 I/O 요청을 한후 입출력 작업이 완료된 후에야 제어가 A 프로그램에 넘어감
  - 구현 방법 1
    - I/O가 끝날 때까지 CPU를 낭비시킴
    - **CPU를 점유하고 있지만 제어는 못하는 상태**
    - 매 시점에 하나의 I/O만 일어날 수 있음
  - 구현 방법 2
    - I/O가 완료될 때까지 A 프로그램에게서 CPU를 빼앗음
    - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
    - **B 프로그램에게 CPU를 넘겨 줌**
- 비동기식 입출력 (asynchronous I/O)
  - I/O가 시작된 후 입출력 작업이 완료될 때까지 기다리지 않고 제어가 A 프로그램에 즉시 넘어감
  - 주로 쓰기(write)에서 사용함(꼭 쓰기가 완료된 이후에 작업해야하는 경우는 별로 없기에)
- 두 구현 모두 I/O의 완료는 인터럽트로 알려줌

## 서로 다른 입출력 명령어

![스크린샷 2024-04-12 오전 10.24.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/16e7931c-bed8-46c3-a7e7-94bf2267a2b2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.24.14.png)

- 일반적인 입출력(왼쪽)
  - 메모리에만 접근하는 명령어(load, store)와 각 I/O 디바이스에 접근하는 명령어가 별개로 나뉘어져있음
- Memory Mapped I/O(오른쪽)
  - I/O 디바이스에 접근하는 명령어를 메모리에 접근하는 명령어의 연장선으로 이용

## 저장장치 계층 구조

![스크린샷 2024-04-12 오전 10.30.19.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/bc681ffa-613a-499d-b886-a275d1d19ebf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.30.19.png)

- 위로 갈수록 속도가 빠르고, 비싸고, 휘발성임
- CPU에서 직접 접근 가능하면 Primary(Executable)라고 함
  - 직접 접근하려면 byte 단위의 접근이 가능해야함
- CPU에서 직접 접근하지 못하면 Secondary
  - byte 단위 접근 X
  - sector 단위임
- 박스 사이즈 = 용량 사이즈
- 캐싱 - 더 빠른 매체로 정보를 읽어들여서 사용

## 프로그램의 실행(메모리 load)

![스크린샷 2024-04-12 오전 10.39.43.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/38f508d0-f9f2-43a8-8fb4-67d65ae4f6da/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.39.43.png)

- 프로그램은 실행 파일의 형태로 하드 디스크에 저장되어있음
- 이 실행 파일을 실행 시키면 메모리에 올라가고, 프로세스가 됨

- 정확히는 물리적인 메모리에 바로 올라가게 되는 게 아니라 한 단계를 더 거치게 되는 게 그게 바로 가상 메모리

![스크린샷 2024-04-12 오전 10.39.22.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/7c5bc924-20ac-45c7-b7fe-7c0fabdbf705/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.39.22.png)

- 어떤 프로그램을 실행시키면 **그 프로그램 만의 독자적인 주소 공간(가상 메모리)이 형성이 됨**
  - 코드(기계어)
  - 데이터(변수)
  - 스택(함수 호출, 리턴 시에 쌓았다가 꺼냈다..)
- 이 독자적인 주소 공간을 물리적인 메모리에 올려서 사용하는데,
  - 운영체제의 커널은 컴퓨터가 켜져있으면 항상 메모리에 상주하고 있지만
  - 각 프로그램은 실행 시점에 주소 공간이 생겼다가, 종료되면 사라짐
    - 따라서 이 주소 공간을 물리적인 메모리에 다 올리지 않음 ⇒ 메모리가 낭비되기 때문
    - 당장 필요한 부분만 물리적인 메모리에 올려둠
    - 그렇지 않은 부분은 디스크의 Swap area에 내려놓음
- File System과 Swap area 둘 다 하드 디스크긴 하지만 용도가 다름

  - File System = 전원이 꺼져도 파일은 그대로여야함(비휘발성)
    - 비휘발성의 용도로 사용됨
  - Swap area = 전원이 꺼지면 무의미해지는 데이터임(휘발성)
    - 전원이 나가면 프로세스, 물리적인 메모리가 다 사라짐
    - 물리적인 메모리의 한계로 사용하는 연장 공간

- Address transition
  - 가상 메모리에서 1000번에 해당하는 코드가 물리적 메모리에 올라가게 되면 3000번이 될 수 있음
  - 따라서 주소를 변환해주는 과정이 필요함
- 운영체제의 커널도 하나의 프로그램이기 때문에, 코드, 데이터, 스택으로 이뤄짐

## 커널 주소 공간의 내용

![스크린샷 2024-04-12 오전 10.50.09.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/c69ac2f3-e25b-4b36-93ea-bb82a03f14e2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.50.09.png)

- 코드
  - 자원을 효율적으로 관리
  - 사용자에게 편한 인터페이스 제공
  - 인터럽트마다 어떤 걸 처리해야하는지 시스템 콜, 인터럽트 처리 코드
- 데이터
  - 운영체제가 사용하는 여러 자료구조가 존재
    - CPU, memory, disk마다 자료 구조를 따로 둬서 사용함
    - 각 프로세스마다 관리를 위한 자료 구조인 PCB가 만들어짐
- 스택
  - 함수 호출, 리턴 시 꺼내고 넣으며 사용
  - 여러 프로그램이 시스템 콜을 통해 운영체제를 호출할 수 있음
    - 어떤 사용자 프로그램이 커널의 코드를 실행 중인가를 나타내기 위해 각 프로그램마다 커널 스택이 따로 존재

## 사용자 프로그램이 사용하는 함수

![스크린샷 2024-04-12 오전 10.54.49.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/1d79167b-97a0-46bb-b8af-12c59bd0cd09/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.54.49.png)

- 사용자 정의 함수
  - 내가 직접 작성한 함수
- 라이브러리 함수
  - 갖다 쓰는 함수

⇒ 둘 다 컴파일하면 실행 파일에 해당 함수가 포함되어있음

- 가상 메모리 상에서의 주소 이동으로 왔다갔다하며 실행됨

  - if문 만나면 점프~
  - return 만나면 점프~

- 커널 함수
  - 운영체제 안에서 정의된 함수
  - 사용자 프로그램의 함수가 아니라, 커널 코드 내에서의 함수
  - 즉, 사용자 프로그램 내에 존재하는 함수가 아니기에 호출만 할 수 있음
    - 사용자 프로그램과 같은 가상 메모리 내에 있는 게 아니기 때문에 사용자 프로그램은 커널함수에 직접 접근하지 못함
    - 따라서 시스템 콜을 통해 사용자 프로그램에서 사용 가능

## 프로그램의 실행

![스크린샷 2024-04-12 오전 11.01.05.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/560f9d7b-142a-4561-95f4-6eaa5fe2caab/3278ff9f-ad6c-41a5-b855-9ee83ce0078f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-12_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.01.05.png)

- User Mode
  - 사용자 프로그램이 CPU를 제어하는 경우
    - 사용자 정의 함수나 라이브러리 코드 호출
    - 자기 주소 내에 있는 코드만 실행
    - 시스템 콜을 하게 되면 커널 모드로 이동
- Kernel Mode
  - 커널 주소 공간의 코드
  - 실행 완료 되면 다시 유저 모드로
- 프로그램은 실행된 이후부터 유저 모드 ↔ 커널 모드를 반복하다가 종료됨
  - CPU를 얻었다가 뺏기는 타이머나 인터럽트는 제외한 그림임
  - 다른 프로그램 제외하고 프로그램 A입장에서 유저모드 커널모드만 본 거임
